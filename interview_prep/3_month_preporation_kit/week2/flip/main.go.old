package main

import (
	"fmt"
)

func flipSlice(s []int32) (fs []int32) {
	for i := len(s)-1; i >= 0; i-- {
		fs = append(fs, s[i])
	}
	return
}

func flipMatrixRow(row int, matrix [][]int32) [][]int32 {
	matrix[row] = flipSlice(matrix[row])
	//fmt.Println()
	//for _, r := range matrix {
	//	fmt.Println(r)
	//}
	//fmt.Println()
	return matrix
}

func getMatrixCol(colNumber int, matrix [][]int32) (col []int32) {
	for i := range matrix {
		col = append(col, matrix[i][colNumber])
	}
	return
}

func flipMatrixCol(col int, matrix [][]int32) [][]int32 {
	fc := getMatrixCol(col, matrix)
	fc = flipSlice(fc)
	for i := range matrix {
		matrix[i][col] = fc[i]
	}
	return matrix
}

func sumArr(arr []int32) (sum int32) {
	for _, v := range arr {
		sum += v
	}
	return
}

func sumUpperLeftQuadrant(matrix [][]int32) (sum int32) {
	for _, arr := range matrix[:len(matrix)/2] {
		sum += sumArr(arr[:len(matrix)/2])
		fmt.Println(arr[:len(matrix)/2])
	}
	fmt.Println("=====")
	fmt.Println(sum)
	fmt.Println()
	return
}

func findLargestPos(arr []int32) (pos int) {
	var largest int32
	for i, v := range arr {
		if v > largest {
			largest = v
			pos = i
		}
	}
	return
}

// shouldFlip return a slice dictating which rows and columns need to be flipped
func flipHandler(matrixType rune, matrixValue int, matrix [][]int32) [][]int32 {
	arr := []int32{}
	switch matrixType {
	case 'c':
		arr = getMatrixCol(matrixValue, matrix)
	case 'r':
		arr = matrix[matrixValue]
	}

	switch {
	// when the first half of the array is smaller than the second half, flip it
	// unless flipping it will disturb the largest number that is the correct half of the matrix
	// but not in the correct quadrent, in which will will flip that first
	// to put it in the correct quadrent and then flip the original arr given
	case sumArr(arr[:len(arr)/2]) < sumArr(arr[len(arr)/2:]) && findLargestPos(arr) < len(arr)/2:
		for _, m := range matrix {
			fmt.Println(m)
		}
		fmt.Println("before-----------")
		fmt.Printf("%d(%d) < %d(%d) && %d < %d\n",sumArr(arr[:len(arr)/2]),arr[:len(arr)/2],sumArr(arr[len(arr)/2:]), arr[len(arr)/2:], findLargestPos(arr), len(arr)/2)
		fmt.Println()
		switch matrixType {
		case 'c':
			fmt.Printf("r%dc%d-----------\n", matrixValue, matrixValue)
			matrix = flipMatrixRow(findLargestPos(arr), matrix)
			matrix = flipMatrixCol(matrixValue, matrix)
			for _, m := range matrix {
				fmt.Println(m)
			}
			fmt.Println("after-----------")
			fmt.Println()
		case 'r':
			fmt.Printf("r%d-----------\n", matrixValue)
			matrix = flipMatrixCol(matrixValue, matrix)
			for _, m := range matrix {
				fmt.Println(m)
			}
			fmt.Println("after-----------")
			fmt.Println()
		}

	// when the first half of the array is smaller than the second half
	// and there are no larger numbers in the way to be disturbed, flip it
	case sumArr(arr[:len(arr)/2]) < sumArr(arr[len(arr)/2:]) && findLargestPos(arr) > len(arr)/2:
		for _, m := range matrix {
			fmt.Println(m)
		}
		fmt.Println("before-----------")
		fmt.Printf("%d(%d) < %d(%d) && %d > %d\n",sumArr(arr[:len(arr)/2]),arr[:len(arr)/2],sumArr(arr[len(arr)/2:]), arr[len(arr)/2:], findLargestPos(arr), len(arr)/2)
		fmt.Println()
		switch matrixType {
		case 'c':
			fmt.Printf("c%d-----------\n", matrixValue)
			matrix = flipMatrixCol(matrixValue, matrix)
			for _, m := range matrix {
				fmt.Println(m)
			}
			fmt.Println("after-----------")
			fmt.Println()
		case 'r':
			fmt.Printf("r%d-----------\n", matrixValue)
			matrix = flipMatrixRow(matrixValue, matrix)
			for _, m := range matrix {
				fmt.Println(m)
			}
			fmt.Println("after-----------")
			fmt.Println()
		}
	}
	return matrix
}

func flippingMatrix(matrix [][]int32) (largestSum int32) {

	for i := range matrix {
		matrix = flipHandler('c', i, matrix)
	}

	for i := range matrix {
		matrix = flipHandler('r', i, matrix)
	}

	
	largestSum = sumUpperLeftQuadrant(matrix)
	return
}


func main() {
	matrix := [][]int32{
		{107, 54, 128, 15},
		{12, 75, 110, 138},
		{100, 96, 34, 85},
		{75, 15, 28, 112}, //488
	}

	//matrix := [][]int32{
	//	{112, 42, 83, 119},
	//	{56, 125, 56, 49},
	//	{15, 78, 101, 43,},
	//	{62, 98, 114, 108},
	//}
	//fmt.Println(sumQuadrant(matrix))
	fmt.Println("Largest:",flippingMatrix(matrix))
}
